# 并发编程

## 1.概览

### 1.1 重点是什么

JAVA平台上的

- 进程
- 线程
- 并发
- 并行

以及JAVA并发工具、并发问题以及解决方案，以及一些其他领域的并发

## 2.进程与线程

- 进程与线程的概念
- 并行与并发的概念
- 线程基本应用

### 2.1 进程与线程

#### 进程

- 程序由指令和数据组成，但是这些指令要运行，数据要读写，就必须将指令加载到CPU，数据加载到内存。在指令运行过程中还需要使用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理IO的。
- 当一个程序被运行，从磁盘加载这个程序的代码到内存，这时就开启了一个进程。
- 进程就可以视作程序的一个实例。大部分程序可以同时运行多个实例进程，也有的程序只能启动一个实例进程。

#### 线程

- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个**指令流**，将指令流中的一条条指令以一定的顺序交给CPU执行。
- Java中，线程作为**最小调度单位**，进程作为**资源分配**的**最小单位**。在windows中进程是不活动的，只是作为线程的容器。

#### 二者对比

- 进程基本上是相互独立的，而线程存在于进程内，是进程的一个子集
- 进程拥有共享的资源，如内存空间等，供其内部的线程共享
- 进程间通信较为复杂
  - 同一台计算机的进程通信成为IPC（Inter-process communication)
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP
- 线程通信相对简单，因为他们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
- 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低



### 2.2 并行和并发

**单核**CPU下，线程实际上还是**串行执行**的。操作系统中有一个组件叫任务调度器，将cpu的时间片分给不同的线程使用，只是由于cpu在线程间的切换非常快，**人类感觉是同时运行**的，总结来说就是**微观串行，宏观并行**。

一般会将这种**线程轮流使用cpu**的做法称为**并发**，concurrent



**多核**CPU下，每个核心都可以调度运行线程，这时候线程可以是**并行**的。



- 并发是同一时间应对（dealing with）多件事情的能力
- 并行是同一时间动手做(doing)多件事情的能力



### 2.3 应用

#### **应用之异步调用**

从方法调用的角度来讲，如果

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

同步在多线程中还有另外一层意思，就是让多个线程步调一致

#### 1) 设计

多线程可以让方法执行变成异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了5秒钟，如果没有线程调度机制，这5秒调用者什么都做不了，其代码都得暂停...

#### 2) 结论

- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程
- tomcat的异步servlet也是类似的目的，让用户线程处理耗时比较长的操作，避免阻塞tomcat的工作线程
- ui程序中，开线程进行其他操作，避免阻塞ui线程 

#### 应用之提高效率

充分利用多核CPU的优势，提高运行效率，执行三个计算，最后将计算结果汇总。

#### 结论

- 单核cpu下，多线程不能实际提高程序运行效率，只是为了能够在不同的人物之间切换，不同线程轮流使用cpu,不至于一个线程总占用cpu，别的线程没法干活
- 多核cpu可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
  - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有的计算任务都可以拆分。
  - 也不是所有任务都需要拆分，任务目的如果不同，谈效率和拆分没有意义
- IO操作不占用CPU，只是一般拷贝文件使用的是**阻塞IO**，这时相当于线程虽然不用CPU，但需要一直等待IO结束，没能充分利用线程。所以才有后面的**非阻塞IO**和**异步IO**优化。

## 3. Java线程

- 创建和运行线程
- 查看线程
- 线程API
- 线程状态

### 3.1创建和运行线程

#### 方法一，直接使用Thread

```java
//创建线程对象
Thread t = new Thread(){
    public void run(){
        //....
    }
};
//启动
t.start;
```

example:

```java
//构造方法的参数是给线程指定名字，推荐
Thread t1 = new Thread("t1"){
    @Override
    //run方法内实现了要执行的任务
    public void run(){
        log.debug("hello");
    }
};
t1.start();
```

#### 方法二 使用Runnable配合Thread

把**线程**和**任务**（要执行的代码）分开

- Thread代表线程
- Runnable 可执行的任务（线程要执行的代码）

```java
Runnable runnable = new Runnable(){
    public void run(){
		// 要执行的任务
    }
};
//创建线程对象
Thread t = new Thread(runnable);
//启动线程
t.start();
```

example:

```java
//创建任务对象
Runnable task2 = new Runnable(){
    @Override
    public void run(){
        log.debug("hello");
    }
};

//参数1是任务对象；参数2是线程名字；推荐
Thread t2 = new Thread(runnable, "t2");
t2.start();
```

