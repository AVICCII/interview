# 备战数据库

# MYSQL

## 1.存储引擎

MYSQL自带有多种类型的存储引擎，在5.5.5版本之前，MYSQL使用的是MYISAM引擎，这种引擎的性能很好，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但是不支持事务以及行间锁，因此，在5.5.5版本之后，采用了Innodb引擎。

**两者的对比：**

1.是否支持行级锁：MyISAM 只有表级锁(table-level locking)，⽽InnoDB ⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁。

2.是否支持事务和崩溃后的安全恢复：MyISAM强调的是性能，每次查询具有原子性，其执行速度比Innodb更快，但是不提供事务支持。但是Innodb提供事务支持服务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe(ACID compliant))型表。

3.是否支持外键:MYISAM不支持，而INNODB支持。

4.是否支持MVVC：仅innoDB支持。应对高并发事务，MVCC比单纯的加锁更加高效;MVCC只在READ COMMITED和REPEATABLE READ两个隔离级别下工作；MVCC可以使用乐观锁(optimistic)锁和悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。


## 2.数据库三大范式

第一范式：每个列都不可以再拆分

第二范式：在第一范式的基础上，消除了部分依赖，非主键列完全依赖于主键，而不能依赖于主键的一部分。

第三范式：在第二范式的基础上，消除了传递依赖。即非主键列只能依赖于主键，不依赖于其他非主键。



## 3.mysql有关权限的表都有哪几个

Mysql服务器通过权限表来控制用户对数据的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别是user,db,table_priv,columns_priv和host。下面分别介绍一下这些表的结构和内容。

- user权限表:记录允许连接到服务器的用户账号信息，里面的权限是全局级的。
- db权限表:记录各个账号在各个数据库上的操作权限。
- table_priv权限表:记录数据表级的操作权限。
- columns_priv权限表:记录数据列级的操作权限。
- host权限表:配合db权限表对给定主机上数据库级操作权限更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。



## 4.MYSQL的binlog有几种录入格式？分别有什么区别？

有三种格式，statement,row和mixed。

- Statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了io，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。
- mixed,一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。



## 5.使用索引查询一定能提高查询的性能吗？为什么

通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。

- 索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的Insert,Delete,Update将为此付出4，5次的磁盘I/O。因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(Index Range Scan)适用于两种情况：

1. 基于一个范围的搜索，一般查询返回结果集小于表中记录数的30%。
2. 基于非唯一性索引的检索。



## 6.索引算法有哪些？

### BTree算法

BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量，例如:

```sql
select * from user where name like 'jack%';
```

### hash算法

Hash索引只能用于对等比较，例如=,<=>(相当于=)操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。



## 7.B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据？

在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。



## 8.聚簇索引和非聚簇索引（主键索引和非主键索引）
主键索引也被称为聚簇索引。
**聚簇索引**： 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。聚簇索引将索引和数据行放到了一块，找到索引也就找到了数据。因为无需进行回表操作，所以效率很高。
**回表查询：InnoDB 中，对于主键索引，只需要走一遍主键索引的查询就能在叶子节点拿到数据。而对于普通索引，叶子节点存储的是 key + 主键值，因此需要再走一次主键索引，通过主键索引找到行记录，这就是所谓的回表查询，先定位主键值，再定位行记录**。
InnoDB中必然且只会有一个聚集索引，一般是主键，如果没有主键，就会优先选择非空的唯一索引，如果唯一索引页没有，就会创建一个隐藏的 row_id 作为聚集索引。
**优点**：由于它将索引和数据保存在同一个B+树中，所以查找效率高，又由于叶子节点间双向链表的存在，是它对主键的排序查找和范围查找速度也非常快；
**缺点**：对表进行修改的速度较慢，因为为了保证表中记录的物理顺序和索引的顺序一致，会把记录插到数据页（叶子节点）的相应位置，所以会产生数据重排，而且插入新记录时为了维持B+树的特性，会频繁的分裂调整，影响了整体插入效率。
所以建议使用聚簇索引的场景是需要进行排序或范围查找的场景，比如实现电子邮箱获取用户邮件时，如果不使用聚簇索引，则每封邮件都可能产生一次磁盘IO，如果采用聚簇索引，根据用户ID来聚集数据，那么只需要从磁盘读取少量的数据页就可以获得某个用户全部的邮件了。（where id > #{maxId}）
（聚簇索引的存储不是物理上连续的，而是逻辑上连续的，这样可以降低维护成本。每张表只能有一个聚簇索引，因为数据页只能按照一棵B+树来排序）
**非聚簇索引**（非主键索引） ：它将数据存储和索引分开，找到索引后，需要通过对应的地址找到对应的数据行。MyISAM 的索引方式就是非聚簇索引。
**缺点**：当通过非聚簇索引来查找数据时，首先遍历找到对应的叶子节点，也就找到了聚簇索引的主键，然后通过聚簇索引找到对应的数据。所以它需要两次索引查找，效率相对较低，这是它的。
**优点**：插入记录时不会引起数据顺序的重组。所以建议使用非聚簇索引的场景是频繁更新的列。



## 9.非聚簇索引一定会回表查询吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。



## 10.联合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因是：

MySQL使用索引时需要索引有序，假设现在建立了"name,age,school"的联合索引，那么索引的排序为:先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询的时候，此时索引仅仅按照name严格有序，因此必须使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用作索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，**一般情况下，将查询寻求频繁或者字段选择性高的列放在前面**。此外可以根据特例的查询或者表结构进行单独的调整。



## 11.索引失效的几种情况？

1. 如果条件中有多个字段使用or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。多条件查询用同一字段时使用or索引会生效。

   ***注意，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引***

2. 对于多列索引，没有使用**第一部分**，则不会使用索引，建立了联合索引，没有使用**联合索引中的第一个索引**搜索时，就不会使用索引。

3. like查询是以%开头

4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引

5. where子句里对索引列上有数据运算，用不上索引

6. where子句里对有索引列使用函数，用不上索引

7. 如果mysql估计使用全局扫描会比使用索引块，则不使用索引，比如数据量极少的表。

8. where子句的查询条件里有不等于号(如：where column!=...),MySQL将无法使用索引。

## 12.大表优化

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常用的优化措施如下:

### 限定数据的范围

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。

### 读写分离

可以将数据库进行一个拆分，主库负责写，从库负责读。

### 垂直分区

**根据数据库里面数据表的相关性进行拆分。**例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分就是指数据表列的拆分，把一张列比较多的表拆分为多张表。**

![image-20210508144136546](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210508144136546.png)

- **垂直拆分的优点：**可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：**主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。

### 水平分区

**保持数据库结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。**

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据过大对性能造成影响。

![image-20210508150401628](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210508150401628.png)

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以**水平拆分最好分库。**

水平拆分能够**支持非常大的数据量存储，应用端改造也少**，但**分片事务难以解决，**跨节点Join性能较差，逻辑复杂。所以**尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度，**一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案**：

- **客户端代理：分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。**

- **中间件代理：在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。**



## 13.解释一下什么是池化设计思想。什么是数据库连接池？为什么需要数据库连接池？

池化设计思想就是通过初始预设资源的方式，来抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。



数据库连接本身就是一个socket的连接。数据库服务端还要维护一些缓存和用户权限信息之类的信息，所以占用了一些内存。我们可以把数据库连接池看作是维护的数据库连接的**缓存，**以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。**连接池还减少了用户必须等待建立与数据库的连接时间。



## 14.分库分表之后，id主键如何处理？

因为要是分成多个表之后，每个表都是从1开始累加，这样是不对的，我们需要一个全局唯一的id来支持。



生成全局id有下面这几种方式:

- **UUID**: 不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。
- **数据库自增id**：两台数据库分别设置不同步长，生成不重复的ID的策略来实现高可用。这种方式生成的id有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。

- **利用redis生成id：**性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。



## 15.一条SQL语句在MYSQL中是如何执行的？

### 查询语句

```sql
select * from tb_student A where A.age='18' and A.name='张三';
```

- 先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在MySQL8.0版本之前，会先查询缓存，以这条sql语句为key在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。
- 通过分析器进行词法分析，提取sql语句的关键元素，比如提取上面这个语句是查询select，提取需要查询的标名为tb_student，需要查询所有的列，查询条件是这个表的id='1'。然后判断这个sql语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。
- 接下来就是优化器进行确定执行方案，上面的sql语句，可以有两种执行方案:

```
a.先查询学生表中姓名为"张三"的学生，然后判断是否年龄为18。
b.先找出学生中年龄18岁的学生，然后再查询姓名为"张三"的学生。
```

那么优化器根据自己的优化算法进行选择执行效率最好的一个方案(优化器认为，有时候不一定是最好)。那么确认了执行计划后就准备开始执行了。

- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

### 更新语句

以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：

```
update tb_student A set A.age='19' where A.name=' 张三 ';
```

我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 **binlog（归档日志）** ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 **redo log（重做日志）**，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：

- 先查询到张三这一条数据，如果有缓存，也是会用到缓存。
- 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。
- 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
- 更新完成。

**这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?**

这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

- **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
- **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

- 判断 redo log 是否完整，如果判断是完整的，就立即提交。
- 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题。



### 总结

- MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。
- 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。•SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验---》查询缓存---》分析器---》优化器---》权限校验---》执行器---》引擎
- 对于更新等语句执行流程如下：分析器----》权限校验----》执行器---》引擎---redo log prepare---》binlog---》redo log commit



## 16.主键、外键、索引的区别

|        | 主键                                       | 外键                                                 | 索引                               |
| ------ | ------------------------------------------ | ---------------------------------------------------- | ---------------------------------- |
| 定义： | 唯一标识一条记录，不能有重复的，不允许为空 | 表的外键是另一表的主键, 外键可以有重复的, 可以是空值 | 该字段没有重复值，但可以有一个空值 |
| 作用： | 用来保证数据完整性                         | 用来和其他表建立联系用的                             | 是提高查询排序的速度               |
| 个数： | 主键只能有一个                             | 一个表可以有多个外键                                 | 一个表可以有多个惟一索引           |



https://blog.csdn.net/weirdowang/article/details/83181346?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.vipsorttest&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.vipsorttest

## 17.事务

### 什么是数据库事务？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

### 事务的四大特性是什么？

**1.原子性**：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。

**2.一致性**：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。

**3.隔离性：**并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。

**4.持久性：**一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 什么是脏读？幻读？不可重复读？

- 脏读(dirty read)：当一个事务正在对一个数据进行操作还未提交修改时，另一个事务读取了该数据，导致该数据是不正确的。
- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？

事务的隔离级别是指数据库为了达到事务的四大特性定义的四种隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

隔离级别	                     脏读	不可重复读	幻影读
READ-UNCOMMITTED	√	           √	             √
READ-COMMITTED	     ×	            √	             √
REPEATABLE-READ	      ×            	×	             √
SERIALIZABLE	               ×	            ×	             ×
SQL 标准定义了四个隔离级别：

- **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读。**

- **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生。**

- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。

- **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读。**

  这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。



## 18.锁

### 对MySQL的锁了解吗

当数据库有并发事务时，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。

就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。

### 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法

在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(InnoDB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎)。

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)
- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁

行级锁，表级锁和页级锁对比

**行级锁：**行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁(读锁和写锁)

特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

**表级锁：**表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁(共享锁)与表独占写锁(排他锁)。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

**页级锁：**页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以去了折中的页级，一次锁定相邻的一组记录。

特点:开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。

### 从锁的类别上分，MYSQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率？

从锁的类别上来讲，有共享锁和排他锁。

共享锁：又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。

排他锁：又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，其他的排他锁，共享锁都相斥。

锁的粒度取决于使用的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。

他们的加锁开销从大到小，并发能力也是从大到小。

### MySQL中的InnoDB引擎的行锁是怎么实现的？

InnoDB是基于索引来完成行锁

eg. select * from tab_with_index where id = 1 for update;

for update可以根据条件来完成行锁锁定，并且id是有索引键的列，如果id不是索引键那么innoDB将完成表锁，并发将无从谈起。

### InnoDB存储引擎的锁的算法有三种

- Record lock:单个行记录上的锁
- Gap lock:间隙锁，锁定一个范围，不包括记录本身
- Next-key lock:record+gap 锁定一个范围，包含记录本身



相关知识点：

1. InnoDB对于行的查询使用了next-key lock

2. Next-locking keying为了解决幻读问题。

3. 当查询的索引含有唯一属性时，将next-key lock降级为record key

4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生

5. 有两种方式显式关闭gap锁:(除了外键约束和唯一性检查外，其余情况仅使用record lock)

   A. 将事务隔离级别设置为RC

   B. 将参数innodb_locks_unsafe_for_binlog设置为1

### 什么是死锁？怎么解决？

死锁是指两个或多个事务在同一资源上互相占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以 大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

### 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统(DBMS)中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制(乐观锁)和悲观并发控制(悲观锁)是并发控制主题要采用的技术手段。

**悲观锁:**假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式:使用数据库中的锁机制

**乐观锁：**假设不会发生并发冲突，只是提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或者CAS算法实现。

### 两种锁的使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，**像乐观锁适用于写比较少的情况下(多读场景)**，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断地进行retry,这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**

### 隔离级别和锁的关系

在Read Uncommited级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突。

在Read Commited级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁。

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交前并不释放共享锁，也就是必须等待事务执行完毕之后才释放共享锁。

SERIALIZABLE是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。



## 19 视图

### 为什么要使用视图？什么是视图？

为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。

视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。



## 20.MySQL慢查询优化

1. 数据库中设置SQL慢查询

   - 修改配置文件来定义慢查询的定义时间。
   - 通过MySQL数据库开启慢查询

2. 分析慢查询日志

   直接分析mysql慢查询日志，利用explain关键字可以模拟优化器执行SQL查询语句，来分析sql慢查询语句。

3. **常见的慢查询优化**

   - **索引没起作用**

     - 使用like关键字的查询语句

     在使用like关键字进行查询的时候，如果匹配字符串的一个字符为"%"，索引不会起作用。只有"%"不在第一个索引才起作用。

     - 使用多列索引的查询语句

     MySQL可以为多个字段创建索引。一个索引最多可以包括16个字段。对于多列索引，只有查询条件使用了这些字段中的第一个字段时，索引才会被使用。

   - **优化数据库结构**

     合理的数据库结构不仅可以使数据库占用更小的磁盘空间，而且能够使查询速度更快。数据库结构的设计，需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

     1. 将字段很多的表分解成多个表

        对于字段比较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

     2. 增加中间表

        对于需要经常联合查询的表，可以建立中间表来提高查询效率。通过建立中间表，把需要经常联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询，以此来提高查询效率。

   - **分解关联查询**

     将一个大的查询分解为多个小查询

   - **优化LIMIT分页**

     在系统中需要分页的操作通常会使用limit加上偏移量的方法实现，同时加上合适的order by子句。如果有对应的索引，通常效率会不错，否则mysql需要做大量的文件排序操作。

   - **分析具体的SQL语句**