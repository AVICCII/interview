# 计算机网络

## 1.计算机网络体系结构

### 1.1 五层协议

![image-20210413152512846](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210413152512846.png)

- **应用层**： 为特定应用程序提供数据传输服务，例如HTTP,DNS等协议。数据单位为报文。

- **传输层**：为**进程**提供通用数据传输服务，由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。传输层包括两种协议：

  - **TCP**传输控制协议：提供**面向连接、可靠**的数据传输服务，数据单位为**报文段**。
  - **UDP**用户数据报协议：提供无连接、尽最大努力的数据传输服务，数据单位为**用户数据报**。

  TCP主要提供**完整性**服务，UDP主要提供**及时性**服务。

- **网络层**：为**主机**提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把数据层传递下来的报文段或者用户数据报封装成**分组**。
- **数据链路层**：网络层针对的还是主机之间的数据传输服务，不过**主机之间可以有很多链路**，链路层协议就是为**同一链路下的主机之间**提供数据传输服务。数据链路层负责将网络层传下来的分组转换成帧。
- **物理层：**考虑如何在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是**尽可能屏蔽传输媒体和通信手段的差异**，使数据链路层感受不到这样的差异。

### 1.2 OSI参考模型

![image-20210413153707407](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210413153707407.png)

OSI模型在五层协议的基础上添加了表示层和会话层。用途如下：

- **表示层：**数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层：**建立及管理会话。

在五层协议中，这些是交给应用程序开发者来处理。

### 1.3 TCP/IP

![image-20210413154407351](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210413154407351.png)

它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。

TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。

## 2.应用层

### 2.1 域名系统（DNS）

DNS是一个分布式数据库，提供了**主机名和IP地址之间相互转换的服务。**在这个概念中的分布式数据库是指**每个站点只保留它自己的那部分数据。**

域名具有层次结构，从上到下分别为：**根域名、顶级域名、二级域名**

![image-20210414093901263](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414093901263.png)

DNS使用TCP/UDP进行传输，端口号为**53**，在**大多数情况下DNS都使用UDP进行传输**，因此需要域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用**TCP**进行传输：

- 如果返回的响应超过**512字节**(超过**UDP最大支持的数据长度**)
- 区域传送(**主域名服务器向辅助域名服务器传送变化的那部分数据**)

### 2.2 文件传输协议（FTP）

FTP使用**TCP**进行链接，需要两个连接来传送一个文件：

- **控制连接：**服务器打开端口号**21**等待客户端的连接，客户端主动建立连接后，使用这个连接将**客户端的命令传送给服务器，并传回服务器的应答**。
- **数据连接：**用来传输文件数据。

根据数据传输是否**服务器端主动建立**，FTP有**主动**和**被动**两种模式：

- 主动模式：服务器端主动建立连接，服务器端的端口号为**20**，客户端的端口号**随机**，由于0~1023是熟知端口号，所以**客户端端口号**需要**大于1024**

  ![image-20210414103522471](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414103522471.png)

- 被动模式：客户端主动建立连接，其中客户端的端口号由客户端自己指定，**服务器端的端口号随机**。

![image-20210414103704819](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414103704819.png)

由于**主动模式**需要客户端开放端口号给服务器端，因此**需要配置客户端的防火墙策略**；而**被动模式**只需要服务器开放端口号即可，**无需配置**客户端的防火墙。但是**被动模式**由于**开放了过多的端口号**，会导致**服务器端**的**安全性减弱**。



### 2.3 动态主机配置协议（DHCP）

DHCP提供了**即插即用**的联网方式，用户**不再需要手动配置IP地址**等信息。

DHCP配置的内容不仅是IP地址，还包括**子网掩码、网关IP地址。**

DHCP的工作过程：

1.**客户端**发送**discover报文**，该报文的目的地址为255.255.255.255:67，源地址为0.0.0.0:68，被放入到**UDP**中，该报文被**广播**（在使用TCP/IP 协议的网络中，主机标识段host ID 为全1 的IP 地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机）到同一个子网的所有主机上。如果客户端和DHCP服务器不在同一个子网，需要使用**中继代理**。

2.**DHCP服务器**收到Discover报文之后，**发送Offer报文**给客户端，该报文包含了**客户端所需要的信息**，因为**客户端可能收到多个**DHCP服务器提供的信息，因此客户端需要进行选择。

3.如果**客户端**选择了某个DHCP服务器提供的信息，那么就发送**Request报文**给该DHCP服务器。

4.**DHCP服务器**端发送**ACK报文**，表示客户端可以使用它提供的信息。

![image-20210414112709647](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414112709647.png)

### 2.4 远程登录协议（TELNET）

TELNET用于**登录到远程主机上**，并且远程主机上的**输出**也会**返回**。

TELNET可以**适应许多计算机和操作系统的差异**，例如**不同操作系统中系统的换行符的定义**。

### 2.5 电子邮件协议

一个电子邮件系统由三部分组成：**用户代理、邮件服务器**以及**邮件协议**。

邮件协议包含**发送协议**和**读取协议**，**发送协议**常用**SMTP**,**读取协议**常用**POP3**和**IMAP**。                          

![image-20210414145358388](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414145358388.png)

#### 1.SMTP

SMTP只能发送ASCII码，而互联网邮件扩充**MIME**可以**发送二进制文件**。MIME并没有改动或者取代SMTP，而是增加邮件主体的结构，定义非ASCII码的编码规则。

![image-20210414145849359](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414145849359.png)

#### 2.POP3

POP3 的特点是只要**用户从服务器上读取了邮件，就把该邮件删除**。但最新版本的 POP3 可以不删除邮件。

#### 3.IMAP

IMAP 协议中**客户端和服务器上的邮件**保持**同步**，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让**用户随时随地去访问服务器上的邮件**。



### 2.6常用端口

![image-20210414151104116](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210414151104116.png)

### 2.7 WEB页面请求过程

#### 1. DHCP配置主机信息

- 假设主机最开始**没有IP地址以及其他信息**，那么就需要先使用**DHCP**来**获取**
- 主机**生成**一个**DHCP请求报文**，并将这个报文放入具有目的端口67和源端口68的UDP报文段中。
- 该报文段则被放入在一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0）的**IP数据报**中。

- 该数据报则被放入到**MAC帧**中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将**广播**到与交换机连接的**所有设备**。
- 连接在交换机的DHCP服务器**收到广播帧**之后，不断的向上分解得到IP数据报、UDP报文段、DHCP请求报文，之后生成DHCP ACK报文，该报文段包含以下信息：**IP地址、DNS服务器的IP地址、默认网关路由器的IP地址和子网掩码**。该报文被放入**UDP报文段**中，**UDP报文段**又被放入到**IP数据报**中，最后放入**MAC帧**中。

- 该帧的目的地址是**请求主机的MAC地址**，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了**MAC地址到其转发接口的交换表项**，因此现在交换机就可以直接知道应该向哪个接口发送该帧。
- 主机收到该帧后，不断分解得到**DHCP报文**，之后就**配置**它的**IP地址、子网掩码和DNS服务器的IP地址**，并在其IP转发表中**安装默认网关**。

#### 2.ARP解析MAC地址

- 主机通过浏览器生成一个**TCP套接字**，**套接字向HTTP服务器发送HTTP请求**。为了**生成该套接字**，主机**需要**知道网站的域名对应的**IP地址**。
- 主机生成一个**DNS查询报文**，该报文具有53号端口，因为DNS服务器的端口号是53。
- 该DNS查询报文被**放入**目的地址为DNS服务器IP地址的**IP数据报**中。
- 该IP数据报被放入一个**以太网帧**中，该帧将发送到网关路由器。
- DHCP过程**只知道网关路由器的IP地址**，**为了获取网关路由器的MAC地址**，需要使用**ARP协议。**
- **主机生成**一个包含**目的地址为网关路由器IP地址**的**ARP查询报文**，将**该ARP查询报文**放入一个具有**广播**目的地址（FF:FF:FF:FF:FF:FF）的**以太网帧**中，并向交换机发送该以太网帧，交换机将该帧**转发给所有的连接设备**，包括**网关路由器**。
- **网关路由器**接收到该帧后，不断向上分解**得到 ARP 报文**，**发现**其中的 IP 地址与其接口的 IP 地址**匹配**，因此就发送一个 **ARP 回答报文**，包含了它的 MAC 地址，发回给主机。

#### 3.DNS解析域名

- 知道了网关路由器的MAC地址后，就可以继续DNS的解析过程了。
- 网关路由器接收到**包含DNS查询报文的以太网帧**后，抽取出**IP数据报**，并根据**转发表**决定该IP数据报应该转发的**路由器**。
- 因为路由器具有**内部网关协议**（RIP、OSPF）和**外部网关协议**（BGP）这两种路由选择协议，因此路由表中已经配置了**网关路由器到达 DNS 服务器的路由表项**。
- 到达 DNS 服务器之后，DNS 服务器抽取出 **DNS 查询报文**，并在 DNS 数据库中。
- 找到 DNS 记录之后，发送 **DNS 回答报文**，将该回答报文放入 **UDP 报文段**中，然后放入 **IP 数据报**中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。

#### 4.HTTP请求页面

- 有了 HTTP 服务器的 **IP 地址**之后，主机就能够生成 **TCP 套接字**，该套接字将用于向 **Web 服务器**发送 **HTTP GET** 报文。
- 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行**三次握手**来建立连接。生成一个具有目的端口 80 的 **TCP SYN** 报文段，并向 HTTP 服务器发送该报文段。
- HTTP 服务器收到该报文段之后，生成 **TCP SYN ACK** 报文段，发回给主机。
- 连接建立之后，浏览器生成 **HTTP GET** 报文，并交付给 HTTP 服务器。
- HTTP 服务器从 TCP 套接字读取 **HTTP GET** 报文，生成一个 **HTTP 响应报文**，将 **Web 页面内容放入报文主体**中，发回给主机。
- 浏览器收到 **HTTP 响应报文**后，抽取出 **Web 页面内容**，之后进行**渲染**，显示 Web 页面。

## 3.传输层

网络层只把分组发送到目的主机，但是**真正通信**的并不是主机而是主机中的**进程**。传输层提供了进程间的**逻辑通信**，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

### 3.1 UDP和TCP的特点

- 用户数据报协议 UDP（User Datagram Protocol）是**无连接**的，**尽最大可能交付**，**没有拥塞控制**，面向**报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持**一对一、一对多、多对一和多对多**的交互通信。

- 传输控制协议 TCP（Transmission Control Protocol）是**面向连接**的，提供**可靠**交付，有**流量控制，拥塞控制**，提供**全双工通信**，面向**字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是**点对点**的（**一对一**）。

### 3.2 UDP首部格式

![image-20210415094052376](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415094052376.png)

首部字段只有 8 个字节，包括**源端口、目的端口、长度、检验和**。12 字节的**伪首部**是为了**计算检验和临时添加的**。

### 3.3 TCP首部格式

![image-20210415145404725](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415145404725.png)

- **序号**：用于对**字节流**进行**编号**，例如序号为301，表示第一个字节的编号为301，如果**携带数据长度为100字节，那么下一个报文段的序号应为401。**
- **确认号**：**期望**收到的**下一个报文段的序号**。例如B正确收到A发送来的一个报文段，序号为501，携带的数据长度为200字节，因此B期望下一个报文段的序号为701，B发送给A的确认报文段中确认号就为701。

- **数据偏移** ：指的是**数据部分**距离报文段**起始**处的**偏移量**，实际上指的是**首部**的**长度**。

- **确认 ACK** ：当 **ACK**=**1** 时确认号字段**有效**，否则无效。TCP 规定，在**连接建立后所有传送的报文段都必须把 ACK 置 1**。

- **同步 SYN** ：在连接建立时用来同步序号。当 **SYN=1，ACK=0** 时表示这是一个**连接请求报文段**。若对方**同意建立连接**，则响应报文中 **SYN=1，ACK=1**。

- **终止 FIN** ：用来释放一个连接，当 **FIN**=**1** 时，表示此报文段的**发送方的数据**已**发送完毕**，并要求**释放连接**。

- **窗口** ：**窗口值**作为**接收方**让**发送方设置其发送窗口的依据**。之所以要有这个限制，是因为**接收方的数据缓存空间**是**有限**的。

### 3.4 TCP的三次握手

假设 A 为客户端，B 为服务器端。

![image-20210415154128832](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415154128832.png)

- B首先处于一个监听的状态，等待客户端的连接请求。
- A向B发送**连接请求报文**，SYN = 1,ACK = 0,选择一个初始的序号x。
- B收到连接请求报文，如果同意建立连接，则向A发送**连接确认**报文，SYN =1，ACK = 1,确认号为x+1,同时也选择一个初始的序号y。
- A收到B的连接确认报文后，还要向B发出确认，**确认号为y+1,序号为x+1**。
- B 收到 A 的确认后，连接建立。

#### 三次握手的原因

第三次握手是为了**防止失效的连接请求到达服务器，让服务器错误打开连接**。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。**客户端等待一个超时重传时间之后，就会重新请求连接**。但是这个滞留的连接请求最后还是会到达服务器，**如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。**

### 3.5 TCP的四次挥手

![image-20210415160506812](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415160506812.png)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 **ACK 在连接建立之后都为 1**。

- A 发送**连接释放报文**，FIN=1。

- B 收到之后发出**确认**，此时 TCP 属于**半关闭状态**，**B 能向 A 发送数据但是 A 不能向 B 发送数据**。

- 当 B 不再需要连接时，发送**连接释放报文**，FIN=1。

- A 收到后发出**确认**，进入 TIME-WAIT 状态，等待 **2 MSL（最大报文存活时间）**后释放连接。

- B **收到** A 的**确认**后**释放连接**。

#### 四次挥手的原因

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- **确保最后一个确认报文能够到达**。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了**让本连接持续时间内所产生的所有报文都从网络中消失**，使得下一个新的连接不会出现旧的连接请求报文。

### 3.6 TCP可靠传输

TCP使用**超时重传**来实现可靠传输：**如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。**

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

![image-20210415170347689](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415170347689.png)

其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：

![image-20210415170432121](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415170432121.png)

其中 RTTd 为偏差的加权平均值。

### 3.7 TCP滑动窗口

窗口是**缓存**的一部分，用来**暂时存放字节流**。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果**发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离**，**直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口**。

**接收窗口只会对窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

![image-20210415171150437](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415171150437.png)

### 3.8 TCP流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

**接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小**，从而**影响发送方的发送速率**。将窗口字段设置为 0，则发送方不能发送数据。

### 3.9 TCP拥塞控制

如果网络**出现拥塞**，**分组**将会**丢失**，此时**发送方**会继续**重传**，从而导致**网络拥塞程度更高**。因此当**出现拥塞**时，应当**控制发送方的速率**。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![image-20210415181952191](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415181952191.png)

TCP 主要通过四个算法来进行**拥塞控制**：**慢开始、拥塞避免、快重传、快恢复。**

发送方需要维护一个叫做**拥塞窗口**（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个**状态变量**，实际决**定发送方能发送多少数据**的是**发送方窗口**。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；

- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

  ![image-20210415184124380](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415184124380.png)

#### 1.慢开始与重传避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到**确认后**，将 cwnd **加倍**，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个**慢开始门限** ssthresh，**当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。**

如果出现了**超时**，则令 ssthresh = **cwnd / 2**，然后重新执行慢开始。

#### 2.快重传和快恢复

在**接收方**，要求**每次接收到报文段**都应该**对最后一个已收到的有序报文段进行确认**。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在**发送方**，如果收到**三个重复确认**，那么可以知道下一个报文段丢失，此时执行**快重传**，**立即重传**下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，**只是丢失个别报文段，而不是网络拥塞**。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时**直接进入拥塞避免**。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![image-20210415184538967](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210415184538967.png)

## 4.网络层

因为网络层是整个互联网的**核心**，因此应当让网络层尽可能简单。网络层向上只提供**简单灵活的、无连接的、尽最大努力交互的数据报**服务。

使用 IP 协议，可以把**异构的物理网络连接起来**，使得在网络层**看起来**好像是一个**统一**的网络。

![image-20210416090211562](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416090211562.png)

与 IP 协议配套使用的还有三个协议：

- 地址解析协议 ARP（Address Resolution Protocol）
- 网际控制报文协议 ICMP（Internet Control Message Protocol）
- 网际组管理协议 IGMP（Internet Group Management Protocol）

### 4.1 IP数据报格式

![image-20210416092237483](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416092237483.png)

- **版本** : 有 4（IPv4）和 6（IPv6）两个值；

- **首部长度** : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。

- **区分服务** : 用来获得更好的服务，一般情况下**不使用**。

- **总长度** : 包括**首部长度**和**数据部分长度**。

- **生存时间** ：TTL，它的存在是为了**防止无法交付的数据报在互联网中不断兜圈子**。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。

- **协议** ：指出**携带的数据应该上交给哪个协议进行处理**，例如 ICMP、TCP、UDP 等。

- **首部检验和** ：因为数据报**每经过一个路由器**，都要**重新计算检验和**，因此**检验和不包含数据部分**可以**减少计算的工作量**。

- **标识** : 在数据报长度过长从而**发生分片**的情况下，**相同数据报的不同分片具有相同的标识符**。

- **片偏移** : 和标识符一起，用于**发生分片**的情况。**片偏移的单位为 8 字节**。

  ![image-20210416095806474](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416095806474.png)

### 4.2 IP地址编址方式

IP 地址的编址方式经历了三个历史阶段：

- 分类
- 子网划分
- 无分类

#### 1.分类

由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。

IP 地址 ::= {< 网络号 >, < 主机号 >}

![image-20210416110025271](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416110025271.png)

#### 2.子网划分

通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。

IP 地址 ::= {< 网络号 >, **< 子网号 >**, < 主机号 >}

要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占**两个比特**，那么子网掩码为 11111111 11111111 **11**000000 00000000，也就是 255.255.192.0。

注意，**外部网络看不到子网的存在**。

#### 3.无分类

无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。

IP 地址 ::= {< 网络前缀号 >, < 主机号 >}

CIDR 的记法上采用在 **IP 地址后面加上网络前缀长度**的方法，例如 128.14.35.7/**20** 表示前 **20 位为网络前缀**。

CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。

一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。

在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。

### 4.3 地址解析协议ARP

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，**IP 数据报**的**源地址和目的地址始终不变**，而 **MAC 地址**随着**链路的改变而改变。**

![image-20210416111259426](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416111259426.png)

ARP 实现由 IP 地址得到 MAC 地址。

![image-20210416111329146](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416111329146.png)

每个主机都有一个 **ARP 高速缓存**，里面有本局域网上的**各主机和路由器**的 **IP 地址到 MAC 地址**的**映射表**。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中**没有**该 **IP 地址到 MAC 地址的映射**，此时主机 A 通过**广播**的方式**发送 ARP 请求分组**，主机 B 收到该请求后会发送 **ARP 响应分组**给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 **IP 地址到 MAC 地址**的映射。

![image-20210416111745164](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416111745164.png)

### 4.4 网际控制报文协议ICMP

ICMP 是为了**更有效地转发 IP 数据报**和**提高交付成功**的机会。它封装在 IP 数据报中，但是不属于高层协议。

![image-20210416111939982](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416111939982.png)

ICMP 报文分为**差错报告报文**和**询问报文**。

![image-20210416112558249](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416112558249.png)

#### 1.Ping

Ping 是 ICMP 的一个重要**应用**，主要用来测试两台主机之间的连通性。

Ping 的原理是通过向目的主机发送 **ICMP Echo 请求报文**，目的主机收到之后会发送 **Echo 回答报文**。**Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。**

#### 2.Traceroute 

Traceroute 是 ICMP 的另一个应用，用来**跟踪一个分组从源点到终点的路径**。

Traceroute 发送的 **IP 数据报**封装的是**无法交付**的 **UDP 用户数据报**，并由**目的主机**发送**终点不可达**差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

### 4.5 虚拟专用网 VPN

由于IP地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

有三个专用地址块：

- 10.0.0.0 ~ 10.255.255.255
- 172.16.0.0 ~ 172.31.255.255
- 192.168.0.0 ~ 192.168.255.255

VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。

下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。

![image-20210416142814314](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416142814314.png)

### 4.6 网络地址转换NAT

专用网内部的主机**使用本地IP地址又想和互联网上的主机通信**时，可以使用NAT来将本地IP转换为全球IP。

在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。

![image-20210416143020027](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416143020027.png)

### 4.7 路由器的结构

路由器从功能上可以划分为：**路由选择**和**分组转发**。

分组转发结构由三个部分组成：**交换结构**、一组**输入端口**和一组**输出端口**。

![image-20210416143403761](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416143403761.png)

### 4.8 路由器分组转发流程

- 从数据报的**首部**提取目的主机的 **IP 地址** D，得到**目的网络地址** N。
- 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；
- 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；
- 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；
- 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；
- 报告转发分组出错。

![image-20210416143628302](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416143628302.png)

### 4.9 路由选择协议

路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统AS,一个AS可以使用一种和别的AS不同的路由选择协议。

可以把路由选择协议划分成两大类：

- 自治系统**内部**的路由选择：RIP 和 OSPF
- 自治系统**之间**的路由选择：BGP

#### 1. 内部网关协议RIP

RIP 是一种基于**距离向量**的**路由选择协议**。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。

RIP 按**固定的时间间隔**仅和**相邻路由器**交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。

距离向量算法：

- 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
- 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
  - 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
  - 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
- 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。

**RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。**

#### 2.内部网关协议OSPF

开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。

开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的**最短路径算法** SPF。

OSPF 具有以下特点：

- 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。
- 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。
- 只有当链路状态发生变化时，路由器才会发送信息。

所有路由器都具有**全网的拓扑结构图**，并且是一致的。**相比于 RIP，OSPF 的更新过程收敛的很快**。

#### 3.外部网关协议BGP

BGP（Border Gateway Protocol，边界网关协议）

AS 之间的路由选择很困难，主要是由于：

- 互联网规模很大；
- 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；
- AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。

**BGP 只能寻找一条比较好的路由，而不是最佳路由。**

每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。

![image-20210416145104201](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416145104201.png)



## 5 数据链路层

### 5.1 基本问题

#### 1.封装成帧

将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。

![image-20210416150452673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416150452673.png)

#### 2.透明传输

透明表示一个实际存在的事物看起来好像不存在一样。

帧使用**首部**和**尾部**进行**定界**，如果**帧的数据部分含有和首部尾部相同的内容**，那么帧的开始和结束位置就会被**错误**的**判定**。需要在数据部分出现首部尾部相同的内容**前面插入转义字符**。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，**用户察觉不到转义字符的存在**。

![image-20210416150521878](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210416150521878.png)

#### 3.差错检测

目前数据链路层广泛使用了**循环冗余检验**（CRC）来检查比特差错。



### 5.2信道分类

#### 1.广播信道

**一对多**通信，一个节点发送的数据能够被广播信道上所有的节点接收到。

所有的节点都在**同一个广播信道**上发送数据，因此需要有专门的控制方法进行协调，**避免**发生**冲突**（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用**信道复用技术**，一是使用 **CSMA/CD 协议**。

#### 2.点对点信道

**一对一**通信。

因为不会发生碰撞，因此也比较简单，使用 **PPP 协议**进行控制。



### 5.3 信道复用技术

#### 1. 频分复用

频分复用的所有主机在相同的时间占用不同的频率带宽资源。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/4aa5e057-bc57-4719-ab57-c6fbc861c505.png)

#### 2. 时分复用

时分复用的所有主机在不同的时间占用相同的频率带宽资源。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/67582ade-d44a-46a6-8757-3c1296cc1ef9.png)



使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。

#### 3. 统计时分复用

是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6283be2a-814a-4a10-84bf-9592533fe6bc.png)

#### 4. 波分复用

光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。

#### 5. 码分复用

为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 和 ![img](https://latex.codecogs.com/gif.latex?\vec{T}) 有

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/308a02e9-3346-4251-8c41-bd5536dab491.png)



为了讨论方便，取 m=8，设码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。

在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6fda1dc7-5c74-49c1-bb79-237a77e43a43.png)



![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e325a903-f0b1-4fbd-82bf-88913dc2f290.png)



其中 ![img](https://latex.codecogs.com/gif.latex?\vec{S%27}) 为 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 的反码。

利用上面的式子我们知道，当接收端使用码片 ![img](https://latex.codecogs.com/gif.latex?\vec{S}) 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。

码分复用需要发送的数据量为原先的 m 倍。

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/99b6060e-099d-4201-8e86-f8ab3768a7cf.png)